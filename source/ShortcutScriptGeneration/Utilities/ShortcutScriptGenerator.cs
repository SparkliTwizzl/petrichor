using Petrichor.ShortcutScriptGeneration.Containers;
using Petrichor.Common.Info;
using Petrichor.Logging;
using System.Text;
using Petrichor.ShortcutScriptGeneration.Exceptions;


namespace Petrichor.ShortcutScriptGeneration.Utilities
{
	public class ShortcutScriptGenerator : IShortcutScriptGenerator
	{
		private string outputFilePath = string.Empty;


		private ShortcutScriptInput Input { get; set; }


		public ShortcutScriptGenerator(ShortcutScriptInput input)
		{
			Input = input;
		}


		public void GenerateScript(string outputFile)
		{
			var outputDirectory = GetNormalizedOutputDirectory(outputFile);
			var outputFileName = GetNormalizedOutputFileName(outputFile);
			outputFilePath = $"{outputDirectory}{outputFileName}";

			var taskMessage = $"generating output file \"{outputFilePath}\"";
			Log.TaskStarted(taskMessage);

			try
			{
				Directory.CreateDirectory(outputDirectory);
				WriteHeaderToFile();
				WriteMacrosToFile();
			}
			catch (Exception ex)
			{
				var errorMessage = $"failed to generate output file ({outputFilePath})";
				Log.Error(errorMessage);
				throw new ScriptGenerationException(errorMessage, ex);
			}
			Log.TaskFinished(taskMessage);
		}

		private string GetNormalizedOutputDirectory(string outputFile)
		{
			var outputDirectory = Path.GetDirectoryName(outputFile);
			if (outputDirectory is null || outputDirectory == string.Empty)
			{
				return ProjectDirectories.OutputDirectory + @"\";
			}
			return outputDirectory + @"\";
		}

		private string GetNormalizedOutputFileName(string outputFile)
		{
			return Path.GetFileNameWithoutExtension( outputFile ) + ".ahk";
		}


		private void WriteByteOrderMarkToFile()
		{
			var encoding = Encoding.UTF8;
			using (FileStream stream = new FileStream(outputFilePath, FileMode.Create))
			{
				using (BinaryWriter writer = new BinaryWriter(stream, encoding))
				{
					writer.Write(encoding.GetPreamble());
				}
			}
		}

		private void WriteConstantsToFile()
		{
			var lines = new string[]
			{
				"; constants used for icon handling",
				"FREEZE_ICON := true",
				"ID_FILE_SUSPEND := 65305",
				"ID_TRAY_SUSPEND := 65404",
				"SUSPEND_OFF := 0",
				"SUSPEND_ON := 1",
				"SUSPEND_TOGGLE := -1",
				"WM_COMMAND := 0x111",
				"",
				"",
			};
			WriteLinesToFile(lines);
		}

		private void WriteControlShortcutsToFile()
		{
			if ( Input.Metadata.ReloadShortcut == string.Empty && Input.Metadata.SuspendShortcut == string.Empty )
			{
				return;
			}

			WriteLineToFile( "; script reload / suspend shortcut(s)" );
			WriteLineToFile( "#SuspendExempt true" );
			if ( Input.Metadata.ReloadShortcut != string.Empty )
			{
				WriteLineToFile( $"{ Input.Metadata.ReloadShortcut }::Reload()" );
			}
			if ( Input.Metadata.SuspendShortcut != string.Empty )
			{
				WriteLineToFile( $"{ Input.Metadata.SuspendShortcut }::Suspend( SUSPEND_TOGGLE )" );
			}
			WriteLineToFile( "#SuspendExempt false" );
			WriteLineToFile();
			WriteLineToFile();
		}
		
		private void WriteControlStatementsToFile()
		{
			var lines = new string[]
			{
				"#Requires AutoHotkey v2.0",
				"#SingleInstance Force",
				"",
			};
			WriteLinesToFile(lines);
		}

		private void WriteGeneratedByMessageToFile()
		{
			var lines = new string[]
			{
				$"; Generated by { AppInfo.AppNameAndVersion } AutoHotkey shortcut script generator",
				"; https://github.com/SparkliTtwizzl/petrichor",
				"",
				"",
			};
			WriteLinesToFile(lines);
		}

		private void WriteHeaderToFile()
		{
			var taskMessage = "writing header to output file";
			Log.TaskStarted(taskMessage);
			WriteByteOrderMarkToFile();
			WriteGeneratedByMessageToFile();
			WriteControlStatementsToFile();
			WriteIconFilePathsToFile();
			WriteConstantsToFile();
			WriteIconHandlingToFile();
			WriteControlShortcutsToFile();
			Log.TaskFinished(taskMessage);
		}

		private void WriteIconFilePathsToFile()
		{
			var lines = new string[]
			{
				$"defaultIcon := \"{ Input.Metadata.DefaultIconFilePath }\"",
				$"suspendIcon := \"{ Input.Metadata.SuspendIconFilePath }\"",
				"",
				"",
			};
			WriteLinesToFile(lines);
		}

		private void WriteIconHandlingToFile()
		{
			var lines = new string[]
			{
				"; icon handling",
				"; based on code by ntepa on autohotkey.com/boards: https://www.autohotkey.com/boards/viewtopic.php?p=497349#p497349",
				"SuspendC := Suspend.GetMethod( \"Call\" )",
				"Suspend.DefineProp( \"Call\",",
				"	{",
				"		Call:( this, mode := SUSPEND_TOGGLE ) => ( SuspendC( this, mode ), OnSuspend( A_IsSuspended ) )",
				"	})",
				"OnMessage( WM_COMMAND, OnSuspendMsg )",
				"OnSuspendMsg( wparam, * )",
				"{",
				"	if ( wparam = ID_FILE_SUSPEND ) || ( wparam = ID_TRAY_SUSPEND )",
				"	{",
				"		OnSuspend( !A_IsSuspended )",
				"	}",
				"}",
				"",
				"OnSuspend( mode )",
				"{",
				"	scriptIcon := SelectIcon( mode )",
				"	SetIcon( scriptIcon )",
				"}",
				"",
				"SelectIcon( suspendMode )",
				"{",
				"	if ( suspendMode = SUSPEND_ON )",
				"	{",
				"		return suspendIcon",
				"	}",
				"	else if ( suspendMode = SUSPEND_OFF )",
				"	{",
				"		return defaultIcon",
				"	}",
				"	return \"\"",
				"}",
				"",
				"SetIcon( scriptIcon )",
				"{",
				"	if ( FileExist( scriptIcon ) )",
				"	{",
				"		TraySetIcon( scriptIcon,, FREEZE_ICON )",
				"	}",
				"}",
				"",
				"SetIcon( defaultIcon )",
				"",
				"",
			};
			WriteLinesToFile(lines);
		}

		private void WriteLineToFile(string line = "")
		{
			try
			{
				using (StreamWriter writer = File.AppendText(outputFilePath))
				{
					writer.WriteLine(line);
				}
			}
			catch (Exception ex)
			{
				var errorMessage = "failed to write line to output file";
				Log.Error(errorMessage);
				throw new FileLoadException(errorMessage, ex);
			}
		}

		private void WriteLinesToFile(string[] lines)
		{
			var linesWritten = 0;
			foreach (string line in lines)
			{
				WriteLineToFile(line);
				++linesWritten;
			}
			Log.Info($"wrote {linesWritten} lines to output file");
		}

		private void WriteMacrosToFile()
		{
			var taskMessage = "writing macros to output file";
			Log.TaskStarted(taskMessage);
			WriteLineToFile( "; macros generated from entries and templates" );
			WriteLinesToFile(Input.Macros);
			Log.TaskFinished(taskMessage);
		}
	}
}
